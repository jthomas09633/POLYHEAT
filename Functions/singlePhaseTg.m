function result = singlePhaseTg(localSegment,min_fit_length,source)
%SINGLEPHASETG Summary of this function goes here
%   Detailed explanation goes here
    result = struct('allSolidStateBaselines',[],...
        'solidStateBaseline',[],...
        'startOfTg',[],...
        'endOfTg',[],...
        'fictiveTemps',[],...
        'fictiveTempMean',[],...
        'deltaCp',[],...
        'meltTemp',[],...
        'heatOfFusionTotal',[],...
        'heatOfFusionFirstContact',[],...
        'heatOfFusionSecondary',[],...
        'semiSolidBaseline',[],...
        'liquidStateBaseline',[],...
        'tanhBaseline',[],...
        'orgIndex',[]);
    solid_state_SOD = fitsStartOfDataTg(localSegment,min_fit_length);
    result.allSolidStateBaselines = solid_state_SOD;
    [best_solid_state_fit,rubbery_state_start] = endOfSSPoint(localSegment,min_fit_length,solid_state_SOD,source);
    result.solidStateBaseline = best_solid_state_fit.bestFitParam;
    result.startOfTg = localSegment(best_solid_state_fit.length,1);
    result.endOfTg = localSegment(rubbery_state_start,1);
    best_rubbery_state = rubberyStateBaselineTg(localSegment,rubbery_state_start,min_fit_length);
    solid_state_end = result.startOfTg;
    rubbery_state_start = result.endOfTg;
    best_solid_state = best_solid_state_fit.baseline;
    try
        [fictive_temp,deltaCp] = fictiveTemp(localSegment,solid_state_end,...
            rubbery_state_start,best_solid_state,best_rubbery_state);
        result.fictiveTemps = fictive_temp;
        result.fictiveTempMean = mean(fictive_temp);
        result.deltaCp = deltaCp;
    catch
        result.fictiveTemps = NaN;
        result.fictiveTempMean = NaN;
        result.deltaCp = NaN;
    end
end

